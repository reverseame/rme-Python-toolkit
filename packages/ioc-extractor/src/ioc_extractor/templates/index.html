<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Graph Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #graph-container {
        width: 100%;
        height: 100%;
      }
      .node {
        stroke: #fff;
        stroke-width: 1.5px;
        cursor: pointer;
      }
      .link {
        stroke: #cbd5e0;
        stroke-opacity: 0.6;
      }
      .nodelabel {
        font-size: 14px;
        fill: #2d3748;
        pointer-events: none;
        text-anchor: middle;
        dominant-baseline: middle;
      }
      .tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.75);
        color: #fff;
        padding: 6px 8px;
        border-radius: 4px;
        font-size: 12px;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="graph-container"></div>
    <div id="tooltip" class="tooltip hidden"></div>

    <script>
      const width = window.innerWidth;
      const height = window.innerHeight;
      const svg = d3
        .select("#graph-container")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
      const g = svg.append("g");

      const zoom = d3
        .zoom()
        .scaleExtent([0.1, 5])
        .on("zoom", (e) => g.attr("transform", e.transform));
      svg.call(zoom);

      const tooltip = d3.select("#tooltip");

      function showTooltip(event, d) {
        let html = `<strong>${d.label}</strong> (${d.count || 0})`;
        if (d.type === "category") {
          html += `<br/>Description: ${d.description || "N/A"}`;
          html += `<br/>Tags: ${d.tags?.join(", ") || "N/A"}`;
        }
        if (d.type === "rule_group" || d.type === "rule_variant") {
          html += `<br/>Description: ${d.description || "N/A"}`;
          html += `<br/>MBCs: ${d.mbcs?.join(", ") || "N/A"}`;
          html += `<br/>ATT&CK: ${d.attck?.join(", ") || "N/A"}`;
        }
        tooltip
          .html(html)
          .style("left", event.pageX + 10 + "px")
          .style("top", event.pageY + 10 + "px")
          .classed("hidden", false);
      }
      function hideTooltip() {
        tooltip.classed("hidden", true);
      }

      function colorByType(type) {
        return (
          {
            root: "#e53e3e",
            category: "#dd6b20",
            rule_group: "#3182ce",
            rule_variant: "#805ad5",
            api: "#38a169",
          }[type] || "#718096"
        );
      }

      fetch("/graph")
        .then((res) => res.json())
        .then(({ elements }) => {
          const rawNodes = elements
            .filter((e) => !e.data.source)
            .map((e) => ({ ...e.data }));
          const rawLinks = elements
            .filter((e) => e.data.source)
            .map((e) => ({
              source: e.data.source,
              target: e.data.target,
            }));

          const nodeMap = Object.fromEntries(
            rawNodes.map((n) => [n.id, { ...n }])
          );
          const childrenMap = {};
          rawLinks.forEach((l) => {
            if (!childrenMap[l.source]) childrenMap[l.source] = [];
            childrenMap[l.source].push(l.target);
          });

          const visibleNodes = new Map(rawNodes.map((n) => [n.id, { ...n }]));
          let links = [...rawLinks];

          const simulation = d3
            .forceSimulation()
            .force(
              "link",
              d3
                .forceLink()
                .id((d) => d.id)
                .distance(120)
                .strength(0.5)
            )
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force(
              "radial",
              d3
                .forceRadial(
                  (d) => {
                    const layer =
                      {
                        root: 0,
                        category: 1,
                        rule_group: 2,
                        rule_variant: 3,
                        api: 4,
                      }[d.type] ?? 5;
                    return layer * 140;
                  },
                  width / 2,
                  height / 2
                )
                .strength(1)
            );

          const linkGroup = g.append("g");
          const nodeGroup = g.append("g");
          const labelGroup = g.append("g");

          function updateGraph() {
            const nodes = Array.from(visibleNodes.values());
            const nodeById = Object.fromEntries(nodes.map((n) => [n.id, n]));

            const validLinks = rawLinks
              .filter((l) => nodeById[l.source] && nodeById[l.target])
              .map((l) => ({
                source: nodeById[l.source],
                target: nodeById[l.target],
              }));

            const linkSel = linkGroup
              .selectAll("line")
              .data(validLinks, (d) => `${d.source.id}-${d.target.id}`);
            linkSel.exit().remove();
            linkSel.enter().append("line").attr("class", "link").merge(linkSel);

            const nodeSel = nodeGroup
              .selectAll("circle")
              .data(nodes, (d) => d.id);
            nodeSel.exit().remove();
            nodeSel
              .enter()
              .append("circle")
              .attr("class", "node")
              .attr("r", (d) => (d.type === "root" ? 36 : 22))
              .attr("fill", (d) => colorByType(d.type))
              .on("mouseover", showTooltip)
              .on("mouseout", hideTooltip)
              .on("click", (_, d) => toggleChildren(d.id))
              .call(
                d3
                  .drag()
                  .on("start", (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                  })
                  .on("drag", (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                  })
                  .on("end", (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                  })
              )
              .merge(nodeSel);

            const labelSel = labelGroup
              .selectAll("text")
              .data(nodes, (d) => d.id);
            labelSel.exit().remove();
            labelSel
              .enter()
              .append("text")
              .attr("class", "nodelabel")
              .text((d) => d.label)
              .merge(labelSel);

            simulation.nodes(nodes);
            simulation.force("link").links(validLinks);
            simulation.alpha(0.8).restart();

            simulation.on("tick", () => {
              nodeGroup
                .selectAll("circle")
                .attr("cx", (d) => d.x)
                .attr("cy", (d) => d.y);

              labelGroup
                .selectAll("text")
                .attr("x", (d) => d.x)
                .attr("y", (d) => d.y);

              linkGroup
                .selectAll("line")
                .attr("x1", (d) => d.source.x)
                .attr("y1", (d) => d.source.y)
                .attr("x2", (d) => d.target.x)
                .attr("y2", (d) => d.target.y);
            });
          }

          function toggleChildren(id) {
            const children = childrenMap[id] || [];
            const anyChildVisible = children.some((child) =>
              visibleNodes.has(child)
            );

            if (anyChildVisible) {
              function recurseRemove(nid) {
                (childrenMap[nid] || []).forEach((child) => {
                  visibleNodes.delete(child);
                  recurseRemove(child);
                });
              }
              recurseRemove(id);
            } else {
              if (!visibleNodes.has(id)) {
                visibleNodes.set(id, nodeMap[id]);
              }
              children.forEach((child) => {
                visibleNodes.set(child, nodeMap[child]);
              });
            }

            updateGraph();
          }

          updateGraph();
        });
    </script>
  </body>
</html>
