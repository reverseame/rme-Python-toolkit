<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>D3 Force Graph with Tooltip</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body {
        margin: 0;
      }
      svg {
        width: 100vw;
        height: 100vh;
        display: block;
      }
      .label {
        font-size: 12px;
        pointer-events: none;
      }
      .tooltip {
        position: absolute;
        background-color: white;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 10px;
        font-family: sans-serif;
        font-size: 13px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease;
        max-width: 300px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <svg></svg>
    <div id="tooltip" class="tooltip"></div>
    <script>
      const svg = d3.select("svg");
      const tooltip = d3.select("#tooltip");
      const width = window.innerWidth;
      const height = window.innerHeight;

      const colorMap = {
        root: "#111",
        category: "#0074D9",
        rule_group: "#2ECC40",
        rule_variant: "#FF851B",
        api: "#B10DC9",
      };

      fetch("/graph")
        .then((res) => res.json())
        .then((data) => {
          const allNodes = new Map();
          const allLinks = [];

          data.elements.forEach((el) => {
            if (el.data.id) {
              allNodes.set(el.data.id, {
                ...el.data,
                visible: true,
                collapsed: false,
                children: [],
                parent: null,
              });
            } else if (el.data.source && el.data.target) {
              allLinks.push({
                source: el.data.source,
                target: el.data.target,
                visible: true,
              });
            }
          });

          const childMap = new Map();
          allLinks.forEach((link) => {
            if (!childMap.has(link.source)) childMap.set(link.source, []);
            childMap.get(link.source).push(link.target);
            allNodes.get(link.source)?.children.push(link.target);
            allNodes.get(link.target).parent = link.source;
          });

          function toggleCollapse(nodeId, collapse) {
            const stack = [nodeId];
            while (stack.length) {
              const currentId = stack.pop();
              const children = childMap.get(currentId) || [];
              for (const childId of children) {
                const child = allNodes.get(childId);
                if (child) {
                  child.visible = !collapse;
                  const link = allLinks.find(
                    (l) => l.source === currentId && l.target === childId
                  );
                  if (link) link.visible = !collapse;
                  stack.push(childId);
                }
              }
            }
          }

          const simulation = d3
            .forceSimulation()
            .force(
              "link",
              d3
                .forceLink()
                .id((d) => d.id)
                .distance(100)
            )
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2));

          function update() {
            const visibleNodes = Array.from(allNodes.values()).filter(
              (n) => n.visible
            );
            const visibleLinks = allLinks.filter(
              (l) =>
                l.visible &&
                allNodes.get(l.source)?.visible &&
                allNodes.get(l.target)?.visible
            );

            const resolvedLinks = visibleLinks.map((l) => ({
              ...l,
              source: allNodes.get(
                typeof l.source === "string" ? l.source : l.source.id
              ),
              target: allNodes.get(
                typeof l.target === "string" ? l.target : l.target.id
              ),
            }));

            simulation.nodes(visibleNodes);
            simulation.force("link").links(resolvedLinks);
            simulation.alpha(0.5).restart();

            const link = svg
              .selectAll("line")
              .data(resolvedLinks, (d) => `${d.source.id}->${d.target.id}`);

            link.exit().remove();

            link
              .enter()
              .append("line")
              .attr("stroke", "#aaa")
              .attr("stroke-width", 1.5);

            const node = svg
              .selectAll("g.node")
              .data(visibleNodes, (d) => d.id);

            node.exit().remove();

            const nodeEnter = node
              .enter()
              .append("g")
              .attr("class", "node")
              .on("click", (event, d) => {
                d.collapsed = !d.collapsed;
                toggleCollapse(d.id, d.collapsed);
                update();
                event.stopPropagation();
              })
              .on("mouseover", (event, d) => {
                if (d.type === "api") {
                  tooltip.style("opacity", 1).html(`
                  <strong>${d.label}</strong><br>
                  <em>${d.command || ""}</em><br>
                  <small>PID: ${d.pid || "N/A"}</small><br><br>
                  <div>${d.description || ""}</div>
                  <div><strong>Tags:</strong> ${d.tags || ""}</div>
                `);
                }
              })
              .on("mousemove", (event) => {
                tooltip
                  .style("left", event.pageX + 10 + "px")
                  .style("top", event.pageY + 10 + "px");
              })
              .on("mouseout", () => {
                tooltip.transition().duration(200).style("opacity", 0);
              })
              .call(
                d3
                  .drag()
                  .on("start", dragstarted)
                  .on("drag", dragged)
                  .on("end", dragended)
              );

            nodeEnter
              .append("circle")
              .attr("r", 12)
              .attr("fill", (d) => colorMap[d.type] || "#ccc");

            nodeEnter
              .append("text")
              .attr("class", "label")
              .attr("x", 15)
              .attr("y", 5)
              .text((d) => d.label);

            svg.selectAll("g.node").merge(nodeEnter);
          }

          simulation.on("tick", () => {
            svg
              .selectAll("line")
              .attr("x1", (d) => d.source?.x)
              .attr("y1", (d) => d.source?.y)
              .attr("x2", (d) => d.target?.x)
              .attr("y2", (d) => d.target?.y);

            svg
              .selectAll("g.node")
              .attr("transform", (d) => `translate(${d.x},${d.y})`);
          });

          function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }

          function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
          }

          function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          }

          update();
        });
    </script>
  </body>
</html>
