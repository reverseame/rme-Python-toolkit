import json
from enum import Enum
from pathlib import Path
from tempfile import NamedTemporaryFile

import vt
from malware_downloader.utils.logger import get_logger
from malware_downloader.utils.utils import shorten
from malware_downloader.utils.wrappers import RawHTML, ratelimiter, save_to, skip_if

VT_METADATA = "virustotal.json"
VT_ALL_BEHAVIOURS = "vt_all_behaviours.json"
VT_BEHAVIOR_SUMMARY = "vt_behavior_summary.json"
VT_MITRE_ATTACK = "vt_mitre_attacks.json"
VT_JUJUBOX_REPORT = "vt_jujubox.json"
VT_CAPE_REPORT = "vt_cape.html"
VT_RATELIMITS = {
    "minute": (4, 60),
    "daily": (500, 86_400),
}

_client = None
vt_ratelimit_min = ratelimiter(*VT_RATELIMITS["minute"])
vt_ratelimit_day = ratelimiter(*VT_RATELIMITS["daily"])
logger = get_logger(__name__)


class VTSandbox(Enum):
    JUJUBOX = "VirusTotal Jujubox"
    CAPE = "CAPE Sandbox"


def set_apikey(apikey: str):
    global _client
    _client = vt.Client(apikey)


def get_client():
    return _client


@vt_ratelimit_day
@vt_ratelimit_min
@skip_if(lambda hash, path: Path(path).joinpath(hash, f"{hash}.zip").exists())
@save_to(lambda hash, path: Path(path).joinpath(hash, f"{hash}.zip"))
def download_sample(hash: str, path: Path):
    logger.info(f"Retrieving file for {shorten(hash)}")
    try:
        with NamedTemporaryFile(delete=False) as tmp:
            _client.download_file(hash, tmp)
            return str(tmp.name)
    except Exception as e:
        raise e


@vt_ratelimit_day
@vt_ratelimit_min
@skip_if(lambda hash, path: Path(path).joinpath(hash, VT_METADATA).exists())
@save_to(lambda hash, path: Path(path).joinpath(hash, VT_METADATA))
def download_metadata(hash: str, path: Path):
    logger.info(f"Retrieving metadata for hash: {shorten(hash)}")
    return _client.get_object(f"/files/{hash}").to_dict()


@vt_ratelimit_day
@vt_ratelimit_min
@skip_if(lambda hash, path: Path(path).joinpath(hash, VT_ALL_BEHAVIOURS).exists())
@save_to(lambda hash, path: Path(path).joinpath(hash, VT_ALL_BEHAVIOURS))
def download_all_behaviours(hash: str, path: Path):
    logger.info(f"Retrieving all behaviour data for hash: {shorten(hash)}")
    return _client.get_data(f"/files/{hash}/behaviours")


@vt_ratelimit_day
@vt_ratelimit_min
@skip_if(lambda hash, path: Path(path).joinpath(hash, VT_BEHAVIOR_SUMMARY).exists())
@save_to(lambda hash, path: Path(path).joinpath(hash, VT_BEHAVIOR_SUMMARY))
def download_behavior_summary(hash: str, path: Path):
    logger.info(f"Retrieving behaviour summary for hash: {shorten(hash)}")
    return _client.get_data(f"/files/{hash}/behaviour_summary")


@vt_ratelimit_day
@vt_ratelimit_min
@skip_if(lambda hash, path: Path(path).joinpath(hash, VT_MITRE_ATTACK).exists())
@save_to(lambda hash, path: Path(path).joinpath(hash, VT_MITRE_ATTACK))
def download_mitre_attack(hash: str, path: Path):
    logger.info(f"Retrieving MITRE ATT&CK mapping for hash: {shorten(hash)}")
    return _client.get_data(f"/files/{hash}/behaviour_mitre_trees")


@vt_ratelimit_day
@vt_ratelimit_min
@skip_if(lambda hash, path: Path(path).joinpath(hash, VT_JUJUBOX_REPORT).exists())
@save_to(lambda hash, path: Path(path).joinpath(hash, VT_JUJUBOX_REPORT))
def download_jujubox_full_report(hash: str, path: Path):
    return _download_full_report(hash, VTSandbox.JUJUBOX)


@vt_ratelimit_day
@vt_ratelimit_min
@skip_if(lambda hash, path: Path(path).joinpath(hash, VT_CAPE_REPORT).exists())
@save_to(lambda hash, path: Path(path).joinpath(hash, VT_CAPE_REPORT))
def download_cape_full_report(hash: str, path: Path):
    return _download_full_report(hash, VTSandbox.CAPE)


#### PRIVATE FUNCTIONS ####
def _download_full_report(hash: str, report_type: VTSandbox):
    logger.info(f"Getting full {report_type.value} report for {shorten(hash)}")
    raw_report = _client.get(f"/file_behaviours/{hash}_{report_type.value}/html").text()

    if raw_report == "":
        logger.error(
            f"[{report_type.value}] Report not available (empty) for {shorten(hash)}"
        )
        return None

    if report_type == VTSandbox.JUJUBOX:
        try:
            logger.info("Detected JUJUBOX, searching for markers")
            # Find and extract the contents
            start_marker = "const Calls = JSON.parse("
            end_marker = "const StrCalls = stringify(Calls);"
            start_pos = raw_report.find(start_marker) + len(start_marker) + 1
            end_pos = raw_report.find(end_marker, start_pos) - 4
            json_string = raw_report[start_pos:end_pos].strip()
            logger.info("returning JSON string")
            return json.loads(json_string)

        except ValueError:
            logger.error(
                f"Could not extract JSON from JujuBox report from {shorten(hash)}"
            )
            return None

    else:  # Other sandboxes
        logger.info("RAW REPORT")
        return RawHTML(raw_report)
