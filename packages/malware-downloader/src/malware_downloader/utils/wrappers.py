import json
import shutil
from functools import wraps
from pathlib import Path
from typing import Any, Callable

from common.logger import get_logger
from malware_downloader.utils.utils import shorten
from ratelimit import limits, sleep_and_retry

logger = get_logger(__name__)


class RawHTML:
    """
    Wrapper class for indicating that the string contained is a raw html
    """

    def __init__(self, content: str):
        self.content = content

    def write_to(self, path: Path):
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w", encoding="utf-8") as f:
            f.write(self.content)


def ratelimiter(calls, period):
    @sleep_and_retry
    @limits(calls=calls, period=period)
    def limiter(func, *args, **kwargs):
        logger.debug(
            f"Executing '{func.__name__}' with rate limit: {calls} calls per {period} secs ({calls / period:.2f} req/s)"
        )
        return func(*args, **kwargs)

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            logger.debug(f"Attempting to call rate-limited function '{func.__name__}'")
            return limiter(func, *args, **kwargs)

        return wrapper

    return decorator


def skip_if(condition: Callable[..., bool]):
    def decorator(func: Callable[..., Any]) -> Callable[..., Any]:
        @wraps(func)
        def wrapper(*args, **kwargs):
            if condition(*args, **kwargs):
                logger.info(
                    f"Skipping '{func.__name__}' execution because condition returned True"
                )
                return None
            logger.debug(f"Condition returned False, executing '{func.__name__}'")
            return func(*args, **kwargs)

        return wrapper

    return decorator


def save_to(output: Callable[..., bool]):
    def decorator(func: Callable[..., Any]) -> Callable[..., Any]:
        @wraps(func)
        def wrapper(*args, **kwargs):
            dest_path = output(*args, **kwargs)
            logger.info(f"Saving result to {shorten(dest_path)}")
            try:
                result = func(*args, **kwargs)

                if result is None:
                    logger.warning(
                        f"'{func.__name__}' returned None â€“ skipping save operation as there is no data"
                    )
                    return

                if isinstance(result, (dict, list)):
                    Path(dest_path).parent.mkdir(parents=True, exist_ok=True)
                    with open(dest_path, "w", encoding="utf-8") as f:
                        json.dump(result, f, indent=2)
                    logger.info(
                        f"JSON result from '{func.__name__}' saved to: {shorten(dest_path)}"
                    )
                elif isinstance(result, str):
                    Path(dest_path).parent.mkdir(parents=True, exist_ok=True)
                    shutil.move(result, dest_path)
                    logger.info(f"Moved file to {shorten(dest_path)}")

                elif isinstance(result, RawHTML):
                    result.write_to(Path(dest_path))
                    logger.info(
                        f"Raw HTML (str) result from '{func.__name__}' saved to: {shorten(dest_path)}"
                    )
                else:
                    logger.error(
                        f"Cannot save result from '{func.__name__}': unsupported type {type(result).__name__}. Expected dict or str."
                    )

                return result

            except Exception as e:
                logger.error(
                    f"Exception occurred in '{func.__name__}' during save operation: {type(e).__name__} - {e}"
                )
                raise

        return wrapper

    return decorator