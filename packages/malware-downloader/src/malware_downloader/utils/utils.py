import re
from pathlib import Path
from typing import Union

from common.logger import get_logger

logger = get_logger(__name__)

HASH_REGEX = re.compile(r"^[0-9a-fA-F]{32}$|^[0-9a-fA-F]{40}$|^[0-9a-fA-F]{64}$")


def run_operation(op, hash_value, output):
    """Execute a single operation with logging, error handling, and stylized output."""
    logger.debug(f"Executing '{op.__name__}' for hash: {shorten(hash_value)}")
    try:
        op(hash_value, output)
        # Generate verb in past tense (e.g., "downloaded metadata")
        op_name = op.__name__.replace("_", " ")
        op_done = op_name.replace(" ", "ed ", 1)
        logger.info(
            f"[bold green reverse] COMPLETED [/bold green reverse] {op_done} for hash: {shorten(hash_value)}"
        )
    except Exception as e:
        logger.error(
            f"[bold red]Error in '{op.__name__}' for {shorten(hash_value)}:[/bold red] {e}"
        )


def load_hashes(value: str) -> list[str]:
    """Load and validate a list of hashes from a file or comma/newline-separated input."""
    path = Path(value)
    try:
        if path.is_file():
            logger.info(f"Detected file input: {value}")
            lines = path.read_text(encoding="utf-8").splitlines()
            hashes = [line.strip() for line in lines if line.strip()]
        elif "." in value and not path.exists():
            raise FileNotFoundError(f"File not found: {value}")
        else:
            logger.debug("Input is not a file, attempting to parse as hash list")
            parts = re.split(r"[,\n]+", value)
            hashes = [part.strip() for part in parts if part.strip()]

        valid_hashes = [h for h in hashes if is_probable_hash(h)]
        invalid = [h for h in hashes if not is_probable_hash(h)]

        if invalid:
            logger.warning(f"Ignoring {len(invalid)} invalid value(s): {invalid}")

        logger.info(f"Loaded {len(valid_hashes)} valid hash(es)")
        return valid_hashes

    except Exception as e:
        logger.error(f"Error loading hashes: {type(e).__name__} - {e}")
        raise


def is_probable_hash(s: str) -> bool:
    """Return True if a string looks like a hash (MD5/SHA1/SHA256)."""
    return bool(HASH_REGEX.fullmatch(s))


def shorten(value: Union[str, Path], prefix=6, suffix=6) -> str:
    """
    Shortens hashes or hash-like segments in paths.
    - Plain hash → shortened + colored.
    - Path → keeps only parts from first hash onward, shortens hash-like segments.
    """
    if isinstance(value, Path):
        value = str(value)

    # Plain value (not a path)
    if "/" not in value and "\\" not in value:
        return (
            f"[purple]{value[:prefix]}...{value[-suffix:]}[/purple]"
            if is_probable_hash(value)
            else value
        )

    sep = "/" if "/" in value else "\\"
    parts = value.split(sep)
    shortened = []

    # Find first index of a hash-like segment
    start = next((i for i, p in enumerate(parts) if is_probable_hash(Path(p).stem)), 0)

    for part in parts[start:]:
        stem, dot, ext = Path(part).stem, ".", Path(part).suffix.lstrip(".")
        if is_probable_hash(stem):
            short = f"{stem[:prefix]}...{stem[-suffix:]}"
            shortened.append(f"{short}{dot + ext if ext else ''}")
        else:
            shortened.append(part)

    return sep.join(shortened)
